// Generated using `moon info`, DON'T EDIT IT
package "tonyfettes/c/atomic"

import(
  "tonyfettes/c"
)

// Values
pub fn[T : CompareExchangeStrong] compare_exchange_strong(@c.Pointer[Atomic[T]], @c.Pointer[T], T) -> Bool

pub fn[T : CompareExchangeWeak] compare_exchange_weak(@c.Pointer[Atomic[T]], @c.Pointer[T], T) -> Bool

pub fn[T : Exchange] exchange(@c.Pointer[Atomic[T]], T) -> T

pub fn[T : FetchAdd] fetch_add(@c.Pointer[Atomic[T]], T) -> T

pub fn[T : FetchAnd] fetch_and(@c.Pointer[Atomic[T]], T) -> T

pub fn[T : FetchOr] fetch_or(@c.Pointer[Atomic[T]], T) -> T

pub fn[T : FetchSub] fetch_sub(@c.Pointer[Atomic[T]], T) -> T

pub fn[T : Init] init_(@c.Pointer[Atomic[T]], T) -> Unit

pub fn[T : Load] load(@c.Pointer[Atomic[T]]) -> T

pub fn[T : Store] store(@c.Pointer[Atomic[T]], T) -> Unit

// Errors

// Types and methods
#external
pub type Atomic[_]
pub impl[T : Sizeof] @c.Sizeof for Atomic[T]

pub(all) enum MemoryOrder {
  Relaxed
  Consume
  Acquire
  Release
  AcqRel
  SeqCst
}

// Type aliases

// Traits
pub(open) trait CompareExchangeStrong {
  compare_exchange_strong(@c.Pointer[Atomic[Self]], @c.Pointer[Self], Self) -> Bool = _
  compare_exchange_strong_explicit(@c.Pointer[Atomic[Self]], @c.Pointer[Self], Self, MemoryOrder, MemoryOrder) -> Bool
}
pub impl CompareExchangeStrong for Int

pub(open) trait CompareExchangeWeak {
  compare_exchange_weak(@c.Pointer[Atomic[Self]], @c.Pointer[Self], Self) -> Bool = _
  compare_exchange_weak_explicit(@c.Pointer[Atomic[Self]], @c.Pointer[Self], Self, MemoryOrder, MemoryOrder) -> Bool
}
pub impl CompareExchangeWeak for Int

pub(open) trait Exchange {
  exchange(@c.Pointer[Atomic[Self]], Self) -> Self = _
  exchange_explicit(@c.Pointer[Atomic[Self]], Self, MemoryOrder) -> Self
}
pub impl Exchange for Int

pub(open) trait FetchAdd {
  fetch_add(@c.Pointer[Atomic[Self]], Self) -> Self = _
  fetch_add_explicit(@c.Pointer[Atomic[Self]], Self, MemoryOrder) -> Self
}
pub impl FetchAdd for Int

pub(open) trait FetchAnd {
  fetch_and(@c.Pointer[Atomic[Self]], Self) -> Self = _
  fetch_and_explicit(@c.Pointer[Atomic[Self]], Self, MemoryOrder) -> Self
}
pub impl FetchAnd for Int

pub(open) trait FetchOr {
  fetch_or(@c.Pointer[Atomic[Self]], Self) -> Self = _
  fetch_or_explicit(@c.Pointer[Atomic[Self]], Self, MemoryOrder) -> Self
}
pub impl FetchOr for Int

pub(open) trait FetchSub {
  fetch_sub(@c.Pointer[Atomic[Self]], Self) -> Self = _
  fetch_sub_explicit(@c.Pointer[Atomic[Self]], Self, MemoryOrder) -> Self
}
pub impl FetchSub for Int

pub(open) trait Init {
  init(@c.Pointer[Atomic[Self]], Self) -> Unit
}
pub impl Init for Int

pub(open) trait Load {
  load(@c.Pointer[Atomic[Self]]) -> Self = _
  load_explicit(@c.Pointer[Atomic[Self]], MemoryOrder) -> Self
}
pub impl Load for Int

pub(open) trait Sizeof {
  sizeof() -> UInt64
}
pub impl Sizeof for Int

pub(open) trait Store {
  store(@c.Pointer[Atomic[Self]], Self) -> Unit = _
  store_explicit(@c.Pointer[Atomic[Self]], Self, MemoryOrder) -> Unit
}
pub impl Store for Int

